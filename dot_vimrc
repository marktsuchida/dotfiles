"
" First section of this file based on vimrc_example.vim
"

source $VIMRUNTIME/defaults.vim

if &t_Co > 2 || has("gui_running")
  set hlsearch
endif

if has('syntax') && has('eval')
  packadd! matchit
endif

"
" End of section based on the example .vimrc file
"


" Detect operating system
let s:is_windows = has("win32") || has("win64")
let s:is_unix = (!s:is_windows) || has("win32unix")
if s:is_unix
  let s:uname = split(system('uname'))[0]
  let s:is_osx = s:uname =~? "Darwin"
else
  let s:is_osx = 0
endif


""" General preference settings

set autoindent
set hidden
set laststatus=2
set encoding=utf-8
set nojoinspaces
set printoptions=paper:letter
set cursorline
set colorcolumn=81,133
highlight ColorColumn term=bold ctermbg=4 guibg=darkgrey
set list
set listchars=trail:▫,tab:‣\ 
set scrolloff=1

" Backups
set backup
set backupcopy=yes
if has('persistent_undo')
  set undofile
endif

" Avoid .sw?, *~, .*.un~ scattered everywhere.
set directory=~/.cache/vim-backups//,.
set backupdir=~/.cache/vim-backups//,.
set undodir=~/.cache/vim-backups/undo//,.


""" Man command
runtime! ftplugin/man.vim
set keywordprg=:Man


""" Japanese input
" fo m = word break at any character above 255
" fo B = join lines without inserting space for any mb char
command Jpn setlocal formatoptions+=mB nospell


""" Edit text without newlines
command FlowText setlocal spell wrap linebreak nocursorline nolist textwidth=0 wrapmargin=0 colorcolumn=


""" Tab setting commands

command Twotab setlocal tabstop=2 shiftwidth=2 expandtab smarttab
command Threetab setlocal tabstop=3 shiftwidth=3 expandtab smarttab
command Fourtab setlocal tabstop=4 shiftwidth=4 expandtab smarttab
command Eighttab setlocal tabstop=8 shiftwidth=8 expandtab smarttab

command Realtwotab setlocal tabstop=2 shiftwidth=2 noexpandtab
command Realthreetab setlocal tabstop=3 shiftwidth=3 noexpandtab
command Realfourtab setlocal tabstop=4 shiftwidth=4 noexpandtab
command Realeighttab setlocal tabstop=8 shiftwidth=8 noexpandtab


""" Good for lisp-like languages
command HyphenatedKeywords setlocal iskeyword=@,48-57,_,-,192-255


""" Print to Preview on OS X
if s:is_osx

  set printexpr=PrintPreview(v:fname_in)
  function PrintPreview(fname)
    call system('open -a Preview '. a:fname . '; rm ' . a:fname)
    return v:shell_error
  endfunc

endif " s:is_osx


""" Filetype-specific settings

" Python
autocmd FileType python Fourtab

" HTML
autocmd FileType html Twotab
autocmd FileType xhtml Twotab

" XML
autocmd FileType xml Fourtab
autocmd FileType xml syntax on
let g:xml_syntax_folding=1
autocmd FileType xml setlocal foldmethod=syntax

" Text
" Following example vimrc (probably to match Vim help files):
autocmd FileType text setlocal textwidth=78

" Markdown
autocmd FileType markdown Twotab
autocmd FileType markdown setlocal textwidth=79

" Vim script
autocmd FileType vim Twotab

" SWIG
autocmd BufNewFile,BufRead *.i setlocal filetype=swig

" Go
autocmd BufRead,BufNewFile *.go setlocal filetype=go

" YAML
autocmd FileType yaml Twotab

" BeanShell
autocmd BufRead,BufNewFile *.bsh setlocal filetype=java
autocmd BufRead,BufNewFile *.bsh Realthreetab

" TypeScript
autocmd BufRead,BufNewFile *.ts setlocal filetype=javascript
autocmd BufRead,BufNewFile *.ts Twotab

" Zip files in disguise (if filetype not already set -- to avoid doubling)
autocmd BufRead,BufNewFile *.jar,*.war,*.whl setfiletype zip

""" Simple text highlighting

function SimpleHighlightSyntax()
  syntax clear
  syntax keyword simpleTodo TODO FIXME XXX REF CHECK
  syntax keyword simpleTodo2 contained TODO FIXME XXX REF CHECK
  syntax match simpleCite "\\cite{[^}]*}"
  syntax match simpleCite2 contained "\\cite{[^}]*}"
  syntax match simpleComment "^#.*" contains=simpleTodo2,simpleCite2
  highlight def link simpleComment Comment
  highlight def link simpleTodo Todo
  highlight def link simpleTodo2 Todo
  highlight def link simpleCite Type
  highlight def link simpleCite2 Type
endfunction
command SimpleHighlight call SimpleHighlightSyntax()
autocmd FileType simple call SimpleHighlightSyntax()


""" SKK (eskk.vim)
let g:eskk#directory = "~/.skk"
let g:eskk#dictionary = {
      \ 'path': "~/.skk/my_jisyo",
      \ 'sorted': 1,
      \ 'encoding': 'utf-8',
      \ }
let g:eskk#large_dictionary = {
      \ 'path': "~/.skk/SKK-JISYO.L",
      \ 'sorted': 1,
      \ 'encoding': 'euc-jp',
      \ }
let g:eskk#enable_completion = 0  " No neocomplete
let g:eskk#egg_like_newline = 1
let g:eskk#keep_state = 1

""" Hex editing

" Enhanced hex mode with proper state management
function! ToggleHex()
  " Check if we're in hex mode
  let l:modified = &mod
  let l:oldreadonly = &readonly
  let &readonly = 0
  let l:oldmodifiable = &modifiable
  let &modifiable = 1

  if !exists("b:editHex") || !b:editHex
    " Save old options
    let b:oldft = &ft
    let b:oldbin = &bin

    " Switch to hex
    let &bin = 1
    let b:editHex = 1
    %!xxd

    " Set filetype for syntax highlighting
    let &ft = "xxd"
  else
    " Convert back from hex
    %!xxd -r

    " Restore old options
    let &ft = b:oldft
    let &bin = b:oldbin
    let b:editHex = 0
  endif

  " Restore modified flag and readonly status
  let &mod = l:modified
  let &readonly = l:oldreadonly
  let &modifiable = l:oldmodifiable
endfunction

command! Hexmode call ToggleHex()

" Convert back to binary for writing
function! HexPreWrite()
  if exists("b:editHex") && b:editHex
    let b:hex_view = winsaveview()
    silent %!xxd -r
  endif
endfunction

function! HexPostWrite()
  if exists("b:editHex") && b:editHex
    silent %!xxd
    call winrestview(b:hex_view)
  endif
endfunction

autocmd BufWritePre * call HexPreWrite()
autocmd BufWritePost * call HexPostWrite()

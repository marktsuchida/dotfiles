{{- /* vim: set filetype=bash: */ -}}

# Exit if not interactive
case $- in
	*i*) ;;
	*) return;;
esac


# Start tmux if we are not already in tmux and not in an editor buffer
if [ -z "$TMUX" ] && [ -z "$VIM_TERMINAL" ] && [ -z "$INSIDE_EMACS" ] &&
	[ -z "$INTELLIJ_ENVIRONMENT_READER" ]
then
	if [ -x /opt/homebrew/bin/tmux ]; then
		if [ ! -x "$(command -v tmux)" ]; then
			PATH="/opt/homebrew/bin:$PATH"
		fi
	fi
	if [ -x "$(command -v tmux)" ]; then
		export EDITOR=vi # Tell tmux to use vi-style keys
		# Create a new session attached to the session group of the
		# 'main' session. The 'main' session is ensured to exist by
		# being created in .tmux.conf. Then make sure the session
		# created here is destroyed when the terminal is detached.
		exec tmux new-session -t main \; set-option destroy-unattached
	else
		echo "tmux not available"
	fi
fi


#
# Actual configuration follows
#

# Note: use 'bash -ic "set -ex; source ~/.bashrc"' to debug.


### Internal functions

prepend_if_not_in_path() {
	if [ -d "$2" ]; then
		if [ -z "${!1}" ]; then
			export $1="$2"
		else
			[[ ":${!1}:" == *":$2:"* ]] || export $1="$2:${!1}"
		fi
	fi
	return 0
}

append_if_not_in_path() {
	if [ -d "$2" ]; then
		if [ -z "${!1}" ]; then
			export $1="$2"
		else
			[[ ":${!1}:" == *":$2:"* ]] || export $1="${!1}:$2"
		fi
	fi
	return 0
}

source_if_file() {
	[ -s "$1" ] && source "$1"
	return 0
}

function_declared() {
	declare -F $1 >/dev/null
	return $?
}


### Generic paths

prepend_if_not_in_path PATH "$HOME/.local/bin"  # E.g., pipx
prepend_if_not_in_path PATH /opt/homebrew/bin
prepend_if_not_in_path PATH /usr/local/bin
prepend_if_not_in_path PATH /usr/local/sbin
prepend_if_not_in_path PATH /opt/local/bin
append_if_not_in_path PATH "$HOME/bin"

# The system may not set MANPATH, instead relying on a config file or a more
# complex mechanism (macOS), so we need to initialize MANPATH before adding to
# it.
[ -x "$(command -v man)" ] && [ -z "$MANPATH" ] && export MANPATH="$(man -w)"
prepend_if_not_in_path MANPATH /opt/homebrew/share/man
prepend_if_not_in_path MANPATH /usr/local/share/man
prepend_if_not_in_path MANPATH /usr/local/man
append_if_not_in_path MANPATH $HOME/man
append_if_not_in_path MANPATH $HOME/share/man

prepend_if_not_in_path INFOPATH /opt/homebrew/share/info
prepend_if_not_in_path INFOPATH /usr/share/info # In case INFOPATH not set
prepend_if_not_in_path INFOPATH /usr/local/share/info
prepend_if_not_in_path INFOPATH /usr/local/info
append_if_not_in_path INFOPATH $HOME/info
append_if_not_in_path INFOPATH $HOME/share/info


### General environment

export PAGER=less
export EDITOR=vim
export VISUAL=vim
export CLICOLOR=1 # Colors for 'ls'


### Bash options

FIGNORE='~'
HISTCONTROL=ignoreboth # Ignore duplicates and lines starting with space
HISTSIZE=1000
HISTFILESIZE=2000
shopt -s checkwinsize globstar histappend


### Prompt and tmux colors

ansi_black=0
ansi_red=1
ansi_green=2
ansi_yellow=3
ansi_blue=4
ansi_magenta=5
ansi_cyan=6
ansi_white=7

case $(uname) in
	Darwin)	ps_color=$ansi_green
		ps_htext=$ansi_white
		tmuxstatusstyle=fg=black,bg=green
		tmuxpaneactiveborderstyle=fg=green
		;;
	Linux)	ps_color=$ansi_yellow
		ps_htext=$ansi_black
		tmuxstatusstyle=fg=black,bg=yellow
		tmuxpaneactiveborderstyle=fg=yellow
		;;
	*)	ps_color=$ansi_blue
		ps_htext=$ansi_white
		tmuxstatusstyle=bg=blue
		tmuxpaneactiveborderstyle=fg=blue
		;;
esac


### Prompts

ps_esc() {
	printf '\[\e'$1'\]'
}

ps_sgr() { # ANSI "select graphic rendition"
	ps_esc "[$1m"
}

ansi_fg=3
ansi_bg=4
ansi_bold=1
ps_sgr_reset=$(ps_sgr)
ps_highlighted=$(ps_sgr "$ansi_bold;$ansi_bg$ps_color;$ansi_fg$ps_htext")
ps_boldcolored=$(ps_sgr "$ansi_bold;$ansi_fg$ps_color")
ps_colored=$(ps_sgr "$ansi_fg$ps_color")
ps_alert=$(ps_sgr "$ansi_bold;$ansi_bg$ansi_white;$ansi_fg$ansi_red")

PS1=
PS1+=$ps_alert'$(ps_print_retval)'$ps_sgr_reset
PS1+=$ps_highlighted'[\u@\h \w]'$ps_sgr_reset
PS1+=$ps_colored'$(ps_git_safe)'$ps_sgr_reset
PS1+='\n'
PS1+=$ps_boldcolored'\! $'$ps_sgr_reset
PS1+=' ' # nbsp for backward-searching

PS2=$ps_highlighted'>'$ps_sgr_reset' '

ps_print_retval() {
	local retval=$?
	[ "$retval" -ne 0 ] && echo " $retval "
}

ps_git_safe() {
	function_declared __git_ps1 && __git_ps1 " (%s)"
}

GIT_PS1_SHOWDIRTYSTATE=1 # * or +
GIT_PS1_SHOWSTASHSTATE=1 # $
GIT_PS1_SHOWUNTRACKEDFILES=1 # %
GIT_PS1_SHOWUPSTREAM=auto # < > <> or =
GIT_PS1_STATESEPARATOR= # No inconsistent space


### Matching tmux colors

if [ -n "$TMUX" ]; then
	tmux set-option -g status-style $tmuxstatusstyle
	tmux set-option -g pane-active-border-style $tmuxpaneactiveborderstyle
fi


### Shell aliases

alias la='ls -A'
alias ll='ls -lFh'
alias lal='ls -lAFh'
alias lsrecent='ls -lFht | head'

alias '..'='cd ..'
alias '...'='cd ../..'
alias '....'='cd ../../..'
alias '.....'='cd ../../../..'

alias tree='tree -I "*~"'
alias octave='octave -q'
alias bc='bc -lq'
alias w3m='w3m -v'
alias hd="od -A x -t x1c"

alias rule='printf \\033[33m◼◼◼◼◼◼◼◼◼◼◼◼◼◼◼◼◼◼◼◼◼◼◼◼◼◼◼◼◼◼◼◼\\033[m\\n'

asciidump()
{
	hexdump -ve '80/1 "%1_p" "\n"' "$@"
}

nkfless()
{
	nkf -w ${1} | less
}


### Application setup

# GNU ls
if [ -x "$(command -v dircolors)" ]; then
	eval $(dircolors --bourne-shell)
	alias ls='ls --color=auto'
fi


# Less
export LESS='-XFRi'
export LESSCHARSET=utf-8
if [ -x "$(command -v source-highlight)" ]; then
	src_hilite_lesspipe=$(command -v src-hilite-lesspipe.sh)
	if [ -x $src_hilite_lesspipe ]; then
		export LESSOPEN="| $src_hilite_lesspipe %s"
	fi
fi


# Gradle: use gradlew when present
gradle() {
	local gradlew=
	local dir=.
	while [ $(cd $dir; pwd) != / ]; do
		if [ -x $dir/gradlew ]; then
			gradlew=$dir/gradlew
			break
		fi
		if [ $dir = . ]; then dir=..; else dir=$dir/..; fi
	done
	if [ -z "$gradlew" ]; then
		gradlew=$(which gradle)
	fi
	if [ -z "$gradlew" ]; then
		echo "neither gradlew nor gradle found"
		return 1
	fi
	echo "[$gradlew]"
	$gradlew "$@"
}


# Node version manager
export NVM_DIR=$HOME/.nvm
source_if_file $NVM_DIR/nvm.sh
source_if_file $NVM_DIR/bash_completion


# Rust
if [ -f "$HOME/.cargo/env" ]; then
	source "$HOME/.cargo/env"
fi


# Ruby rbenv
if [ -x "$(command -v rbenv)" ]; then
	eval "$(rbenv init -)"
fi

if [ -x "$(command -v gem)" ]; then
	gem_user_install=$(gem env |grep 'USER INSTALLATION DIRECTORY: ' |awk '{ print $NF }')
	append_if_not_in_path PATH $gem_user_install/bin
fi


# Miniconda

if [ -x "$HOME/miniconda3/bin/conda" ]; then
	eval "$("$HOME/miniconda3/bin/conda" 'shell.bash' 'hook')"
fi


# Aliases to set git config
alias git-config-wisc='git config user.email matsuchida@wisc.edu && git config user.name "Mark A. Tsuchida"'
alias git-config-gmail='git config user.email marktsuchida@gmail.com && git config user.name "Mark A. Tsuchida"'


#
# OS-specific settings
#

{{ if eq .chezmoi.os "darwin" }}
{{ template "bashrc-darwin.tmpl" . }}
{{- else if eq .chezmoi.os "windows" }}
{{ template "bashrc-windows.tmpl" . }}
{{- else if (and (eq .chezmoi.os "linux")
                 (or (eq .chezmoi.osRelease.idLike "debian")
                     (eq .chezmoi.osRelease.id "debian"))) }}
{{ template "bashrc-debian.tmpl" . }}
{{- end }}


#
# Local settings
#
source_if_file .bashrc-local


# Ignore any settings that various installers might "smartly" append.
return

# -- last line of intended content --

{{- /* vim: set filetype=bash: */ -}}

# Hide the "default is zsh" notice
export BASH_SILENCE_DEPRECATION_WARNING=1


# macOS /etc/bashrc sources /etc/bashrc_Apple_Terminal, which sets up
# PROMPT_COMMAND to tell Terminal.app the cwd. I don't need this.
if [ "$PROMPT_COMMAND" = "update_terminal_cwd" ]; then
	unset PROMPT_COMMAND
fi


### Shell aliases
if [ -x "$(command -v ggrep)" ]; then
	alias grep='ggrep --color=auto'
	alias fgrep='gfgrep --color=auto'
	alias egrep='gegrep --color=auto'
fi
alias 'open.'='open .'
alias preview='open -a Preview'
alias skim='open -a Skim'
alias acroread='open -a "Adobe Reader.app"'
alias chrome='open -a "Google Chrome.app"'
alias pbclear='pbcopy < /dev/null'

alias xcode-select-xcode='sudo xcode-select -s /Applications/Xcode.app/Contents/Developer'
alias xcode-select-command-line-tools='sudo xcode-select -s /Library/Developer/CommandLineTools'

vimpb()
{
	tmpfile=$(mktemp /tmp/vimpb-XXXXXX)
	pbpaste >$tmpfile
	vim $tmpfile
	pbcopy <$tmpfile
	rm -f $tmpfile
}

manskim()
{
	man -t "$@" | open -f -a Skim
}

manprev()
{
	man -t "$@" | open -f -a Preview
}

doi()
{
	open http://dx.doi.org/${1}
}

# Capture QR code (or any barcode) from selection and print content to stdout.
qrcapture()
{
	tmpdir=$(mktemp -d /tmp/capture-qr-XXXXXX)
	qrpng=$tmpdir/qr.png
	screencapture -i $qrpng
	zbarimg -q --raw $qrpng
	rm -rf $tmpdir
}

# Similar, but OCR by Tesseract; pass any args (such as '-l jpn') to tesseract.
ocrcapture()
{
	tmpdir=$(mktemp -d /tmp/capture-ocr-XXXXXX)
	screencapture -i $tmpdir/text.png
	# Tesseract seems to erroneously access the file basename, so change to
	# the directory.
	pushd $tmpdir >/dev/null
	tesseract text.png - "$@" quiet
	popd >/dev/null
	rm -rf $tmpdir
}

# Show desktop notification
notify()
{
	title="$1"
	shift
	message="$@"
	osascript -e "display notification \"$message\" with title \"$title\""
}


### Homebrew
if [ -x /opt/homebrew/bin/brew ]; then
	eval "$(/opt/homebrew/bin/brew shellenv)"
fi

# Bash completions
# This should be sufficient for bash-completion@2 to load everything, including
# the scripts installed in $BASH_COMPLETION_COMPAT_DIR.
source_if_file /usr/local/etc/profile.d/bash_completion.sh
source_if_file /opt/homebrew/etc/profile.d/bash_completion.sh


### Application setup

# MacVim
if [ -x /Applications/MacVim.app/Contents/bin/mvim ]; then
	append_if_not_in_path PATH "/Applications/MacVim.app/Contents/bin"
fi


# MacTeX
# PATH and MANPATH are automatically added by system, via path_helper(8)
prepend_if_not_in_path INFOPATH /Library/TeX/Distributions/.DefaultTeX/Contents/Info


# Visual Studio Code 'code' command
append_if_not_in_path PATH "/Applications/Visual Studio Code.app/Contents/Resources/app/bin"


# Google Cloud Platform
source_if_file ~/google-cloud-sdk/path.bash.inc
source_if_file ~/google-cloud-sdk/completion.bash.inc


# Gnuplot
export GNUTERM=qt


# Go (Homebrew)
if [ -x "$(command -v go)" ]; then
	export GOROOT=/usr/local/opt/go/libexec
	append_if_not_in_path PATH $GOROOT/bin
fi


# Java
export JAVA_HOME=$(/usr/libexec/java_home -v 1.8)
if [ ! -z "$JAVA_HOME" ]; then
	append_if_not_in_path MANPATH "$JAVA_HOME/man"
fi


# Groovy (Homebrew)
if [ -x /usr/local/bin/groovysh ] && [ -d /usr/local/opt/groovy ]; then
	export GROOVY_HOME=/usr/local/opt/groovy/libexec
fi


# Python
# Homebrew still installs 'python3'
alias python=python3
# Leave out 'alias pip=pip3' because global pip should be used with caution


# Micromamba

# >>> mamba initialize >>>
# !! Contents within this block are managed by 'mamba init' !!
export MAMBA_EXE='/opt/homebrew/opt/micromamba/bin/micromamba';
export MAMBA_ROOT_PREFIX="$HOME/micromamba";
__mamba_setup="$("$MAMBA_EXE" shell hook --shell bash --root-prefix "$MAMBA_ROOT_PREFIX" 2> /dev/null)"
if [ $? -eq 0 ]; then
    eval "$__mamba_setup"
else
    alias micromamba="$MAMBA_EXE"  # Fallback on help from mamba activate
fi
unset __mamba_setup
# <<< mamba initialize <<<


# macOS manpath fix
#
# macOS has 2 non-standard ways to configure paths for man(1):
# 1. path_helper(8), which assembles a list of paths from /etc/manpaths.d and
#    _prepends_ them to MANPATH, but only if MANPATH exists (empty or not). It
#    also always appends a ':' at the end of MANPATH (which is self-defeating
#    given what manpath(1) does).
# 2. manpath(1), which has two modes of operation:
#    - If MANPATH is unset or contains an empty colon-separated field, it
#      constructs the paths entirely based on PATH
#    - Otherwise (if MANPATH is a nonempty list of paths with no empty item),
#      it returns MANPATH unmodified.
# The current Apple-expected behavior is that we just get manpath(1)'s PATH-
# based list, and no method is provided (as far as I can tell) to combine this
# with additional user-supplied paths.
#
# The platform-neutral bashrc has constructed a MANPATH up to here. In
# addition, we also want the paths provided by path_helper(8) (e.g., XQuartz,
# TeX Live). So do a bit of a dance to combine all into a static MANPATH
# containing no stray colons.

# Remove leading, trailing, or repeated colons.
clean_path() {
    local input="$1"
    local output=""
    local IFS=":"

    # Split the input by colons into an array
    read -ra parts <<< "$input"

    # Rebuild the path with only non-empty parts
    for part in "${parts[@]}"; do
        if [[ -n "$part" ]]; then
            if [[ -z "$output" ]]; then
                output="$part"
            else
                output="$output:$part"
            fi
        fi
    done

    echo "$output"
}

# We don't need path_helper to add stuff to PATH, because it already would have
# via /etc/profile (at which time MANPATH would have been unset).
tmp_save_path="$PATH"
if [ -x /usr/libexec/path_helper ]; then
	export MANPATH=:
	eval `/usr/libexec/path_helper -s`
fi
tmp_classic_manpath="$MANPATH"
unset MANPATH
tmp_path_based_manpath=$(manpath)
export MANPATH="$(clean_path "$tmp_path_based_manpath:$tmp_classic_manpath")"
export PATH="$tmp_save_path"
unset tmp_save_path
unset tmp_classic_manpath
unset tmp_path_based_manpath
